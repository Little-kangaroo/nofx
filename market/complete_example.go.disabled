package market

import (
	"fmt"
	"log"
	"time"
)

// CompleteAnalysisExample å®Œæ•´çš„å››æ¨¡å—åˆ†æç¤ºä¾‹
func CompleteAnalysisExample() {
	fmt.Println("=== å®Œæ•´å¸‚åœºåˆ†æç³»ç»Ÿç¤ºä¾‹ ===")
	fmt.Println("åŒ…å«: é“æ°ç†è®º + VPVR + ä¾›éœ€åŒº + FVG å››å¤§åˆ†ææ¨¡å—")

	// 1. ç”Ÿæˆç»¼åˆç¤ºä¾‹Kçº¿æ•°æ®
	klines := generateCompleteAnalysisKlines()
	fmt.Printf("ç”Ÿæˆäº† %d æ ¹Kçº¿æ•°æ®ï¼ŒåŒ…å«å„ç§å¸‚åœºç»“æ„\n", len(klines))

	// 2. åˆ›å»ºç»¼åˆåˆ†æå™¨
	analyzer := NewComprehensiveAnalyzer()
	fmt.Println("ç»¼åˆåˆ†æå™¨å·²åˆ›å»ºï¼ŒåŒ…å«æ‰€æœ‰å››ä¸ªåˆ†ææ¨¡å—")

	// 3. æ‰§è¡Œå®Œæ•´åˆ†æ
	symbol := "BTCUSDT"
	result := analyzer.Analyze(symbol, nil, klines)
	if result == nil {
		log.Println("ç»¼åˆåˆ†æå¤±è´¥")
		return
	}

	// 4. æ˜¾ç¤ºå®Œæ•´åˆ†æç»“æœ
	displayCompleteResults(result)

	// 5. æ¼”ç¤ºæƒé‡ä¼˜åŒ–é…ç½®
	optimizedConfig := &ComprehensiveConfig{
		EnableDowTheory:    true,
		EnableVPVR:         true,
		EnableSupplyDemand: true,
		EnableFVG:          true,
		WeightDowTheory:    0.35, // é“æ°ç†è®ºä½œä¸ºä¸»è¦è¶‹åŠ¿åˆ¤æ–­
		WeightVPVR:         0.25, // VPVRæä¾›å…³é”®ä»·ä½
		WeightSupplyDemand: 0.25, // ä¾›éœ€åŒºæä¾›ç²¾ç¡®å…¥åœºç‚¹
		WeightFVG:          0.15, // FVGä½œä¸ºè¾…åŠ©ç¡®è®¤
		MinConfidence:      65.0,
		MaxSignals:         5,
	}

	optimizedAnalyzer := NewComprehensiveAnalyzerWithConfig(optimizedConfig)
	optimizedResult := optimizedAnalyzer.Analyze(symbol, nil, klines)
	if optimizedResult != nil {
		fmt.Println("\n" + strings.Repeat("=", 60))
		fmt.Println("=== æƒé‡ä¼˜åŒ–é…ç½®åˆ†æç»“æœ ===")
		displayCompleteResults(optimizedResult)
		compareAnalysisResults(result, optimizedResult, "é»˜è®¤é…ç½®", "ä¼˜åŒ–é…ç½®")
	}

	// 6. æ¼”ç¤ºå®æ—¶äº¤æ˜“å†³ç­–æµç¨‹
	demonstrateTradingDecisionProcess(analyzer, symbol, klines)
}

// generateCompleteAnalysisKlines ç”ŸæˆåŒ…å«æ‰€æœ‰ç»“æ„çš„ç¤ºä¾‹Kçº¿
func generateCompleteAnalysisKlines() []Kline {
	klines := make([]Kline, 150)
	basePrice := 50000.0
	baseTime := time.Now().UnixMilli() - int64(150*4*3600*1000) // 150æ ¹4å°æ—¶Kçº¿

	for i := range klines {
		var open, high, low, close, volume float64

		// ç”Ÿæˆå¤æ‚çš„å¸‚åœºç»“æ„ï¼ŒåŒ…å«æ‰€æœ‰åˆ†æè¦ç´ 
		switch {
		case i < 20:
			// é˜¶æ®µ1: åˆå§‹ä¸‹è·Œï¼ˆå½¢æˆä¾›ç»™åŒºï¼‰
			trend := float64(i) * -60
			open = basePrice + 3000 + trend + float64(i%7-3)*120
			close = open + float64(i%5-2)*100 - 200

		case i < 35:
			// é˜¶æ®µ2: åº•éƒ¨æ•´ç†ï¼ˆéœ€æ±‚åŒºå½¢æˆ + çœ‹æ¶¨FVGï¼‰
			open = basePrice + 1800 + float64(i%6-3)*80
			close = open + float64(i%4-2)*60
			// åœ¨Kçº¿30-32ä¹‹é—´åˆ›å»ºçœ‹æ¶¨FVG
			if i == 30 {
				high = open + 100
				low = open - 50
			} else if i == 31 {
				// è·³ç©ºå‘ä¸Šï¼ˆå½¢æˆFVGï¼‰
				open = basePrice + 1800 + 400
				close = open + 300
				volume = 250 // é«˜æˆäº¤é‡
			} else if i == 32 {
				open = basePrice + 1800 + 700
				close = open + 200
			}

		case i < 60:
			// é˜¶æ®µ3: ä¸Šæ¶¨è¶‹åŠ¿ï¼ˆé“æ°ç†è®ºä¸Šå‡é€šé“ï¼‰
			trend := float64(i-35) * 80
			open = basePrice + 2200 + trend + float64(i%5-2)*100
			close = open + float64(i%6)*120 + 150

		case i < 75:
			// é˜¶æ®µ4: é«˜ä½æ•´ç†ï¼ˆä¾›ç»™åŒºå½¢æˆ + çœ‹è·ŒFVGï¼‰
			open = basePrice + 4200 + float64(i%8-4)*150
			close = open + float64(i%5-2)*80
			// åœ¨Kçº¿70-72ä¹‹é—´åˆ›å»ºçœ‹è·ŒFVG
			if i == 70 {
				high = open + 80
				low = open - 120
			} else if i == 71 {
				// è·³ç©ºå‘ä¸‹ï¼ˆå½¢æˆçœ‹è·ŒFVGï¼‰
				open = basePrice + 4200 - 300
				close = open - 250
				volume = 220 // é«˜æˆäº¤é‡
			} else if i == 72 {
				open = basePrice + 4200 - 600
				close = open - 150
			}

		case i < 90:
			// é˜¶æ®µ5: ä¸‹è·Œè¶‹åŠ¿
			trend := float64(i-75) * -50
			open = basePrice + 3600 + trend + float64(i%6-3)*120
			close = open + float64(i%7-4)*80 - 180

		case i < 110:
			// é˜¶æ®µ6: åå¼¹æµ‹è¯•ï¼ˆæµ‹è¯•ä¾›ç»™åŒºå’ŒFVGï¼‰
			trend := float64(i-90) * 60
			open = basePrice + 2800 + trend + float64(i%5-2)*100
			close = open + float64(i%4)*100 + 120

		case i < 125:
			// é˜¶æ®µ7: æ¨ªç›˜æ•´ç†ï¼ˆä»·å€¼åŒºåŸŸå½¢æˆï¼‰
			open = basePrice + 3200 + float64(i%10-5)*100
			close = open + float64(i%6-3)*70

		default:
			// é˜¶æ®µ8: æœ€æ–°èµ°åŠ¿ï¼ˆå½“å‰å¸‚åœºçŠ¶æ€ï¼‰
			trend := float64(i-125) * 40
			open = basePrice + 3100 + trend + float64(i%7-3)*90
			close = open + float64(i%8-4)*80
		}

		// è®¡ç®—æœ€é«˜ä»·å’Œæœ€ä½ä»·
		if close > open {
			if high == 0 {
				high = max(open, close) + float64(i%4)*60
			}
			if low == 0 {
				low = min(open, close) - float64(i%3)*50
			}
		} else {
			if high == 0 {
				high = max(open, close) + float64(i%3)*50
			}
			if low == 0 {
				low = min(open, close) - float64(i%4)*60
			}
		}

		// ç¡®ä¿ä»·æ ¼åˆç†æ€§
		if low < open*0.98 {
			low = open * 0.98
		}
		if high > open*1.02 {
			high = open * 1.02
		}

		// é»˜è®¤æˆäº¤é‡ï¼ˆå¦‚æœæœªè®¾ç½®ï¼‰
		if volume == 0 {
			priceChange := abs(close - open)
			baseVolume := 150.0
			volumeMultiplier := 1.0 + priceChange/open*8
			volume = baseVolume * volumeMultiplier * (1 + float64(i%6)*0.25)
		}

		klines[i] = Kline{
			OpenTime:            baseTime + int64(i*4*3600*1000),
			Open:                open,
			High:                high,
			Low:                 low,
			Close:               close,
			Volume:              volume,
			CloseTime:           baseTime + int64((i+1)*4*3600*1000) - 1,
			QuoteVolume:         volume * (high + low) / 2,
			Trades:              int(volume / 15),
			TakerBuyBaseVolume:  volume * 0.58,
			TakerBuyQuoteVolume: volume * 0.58 * close,
		}
	}

	return klines
}

// displayCompleteResults æ˜¾ç¤ºå®Œæ•´åˆ†æç»“æœ
func displayCompleteResults(result *ComprehensiveResult) {
	if result == nil {
		fmt.Println("æ— åˆ†æç»“æœ")
		return
	}

	fmt.Printf("\n=== %s å››æ¨¡å—ç»¼åˆåˆ†æç»“æœ ===\n", result.Symbol)
	fmt.Printf("åˆ†ææ—¶é—´: %s\n", time.UnixMilli(result.Timestamp).Format("2006-01-02 15:04:05"))
	fmt.Printf("å½“å‰ä»·æ ¼: %.2f\n", result.CurrentPrice)

	// 1. å„æ¨¡å—çŠ¶æ€æ¦‚è§ˆ
	displayModuleStatus(result)

	// 2. å¸‚åœºç»“æ„åˆ†æ
	displayMarketStructure(result.MarketStructure)

	// 3. å…³é”®ä»·ä½æ±‡æ€»
	displayKeyLevelsSummary(result.MarketStructure)

	// 4. ç»Ÿä¸€äº¤æ˜“ä¿¡å·
	displayUnifiedSignals(result.UnifiedSignals)

	// 5. é£é™©è¯„ä¼°
	displayRiskAssessment(result.RiskAssessment)

	// 6. æœ€ç»ˆäº¤æ˜“å»ºè®®
	displayFinalTradingAdvice(result.TradingAdvice)

	// 7. è¯¦ç»†æ¨¡å—åˆ†æ
	displayDetailedModuleAnalysis(result)
}

// displayModuleStatus æ˜¾ç¤ºå„æ¨¡å—çŠ¶æ€
func displayModuleStatus(result *ComprehensiveResult) {
	fmt.Printf("\n=== åˆ†ææ¨¡å—çŠ¶æ€ ===\n")

	// é“æ°ç†è®ºçŠ¶æ€
	if result.DowTheory != nil && result.DowTheory.TrendStrength != nil {
		fmt.Printf("ğŸ“ˆ é“æ°ç†è®º: %sè¶‹åŠ¿ (å¼ºåº¦: %.1f, è´¨é‡: %s)\n",
			getTrendDirectionName(result.DowTheory.TrendStrength.Direction),
			result.DowTheory.TrendStrength.Overall,
			getTrendQualityName(result.DowTheory.TrendStrength.Quality))
	} else {
		fmt.Printf("ğŸ“ˆ é“æ°ç†è®º: æ•°æ®ä¸è¶³\n")
	}

	// VPVRçŠ¶æ€
	if result.VolumeProfile != nil && result.VolumeProfile.POC != nil {
		fmt.Printf("ğŸ“Š VPVR: POC %.2f, ä»·å€¼åŒº %.2f-%.2f, é›†ä¸­åº¦ %.2f\n",
			result.VolumeProfile.POC.Price,
			result.VolumeProfile.VAL,
			result.VolumeProfile.VAH,
			result.VolumeProfile.ValueArea.Concentration)
	} else {
		fmt.Printf("ğŸ“Š VPVR: æ•°æ®ä¸è¶³\n")
	}

	// ä¾›éœ€åŒºçŠ¶æ€
	if result.SupplyDemand != nil && result.SupplyDemand.Statistics != nil {
		stats := result.SupplyDemand.Statistics
		fmt.Printf("âš–ï¸  ä¾›éœ€åŒº: %dä¸ªæ´»è·ƒ (ä¾›ç»™:%d, éœ€æ±‚:%d), æˆåŠŸç‡: %.1f%%\n",
			len(result.SupplyDemand.ActiveZones),
			stats.ActiveSupplyZones,
			stats.ActiveDemandZones,
			stats.SuccessRate)
	} else {
		fmt.Printf("âš–ï¸  ä¾›éœ€åŒº: æ•°æ®ä¸è¶³\n")
	}

	// FVGçŠ¶æ€
	if result.FairValueGaps != nil && result.FairValueGaps.Statistics != nil {
		stats := result.FairValueGaps.Statistics
		fmt.Printf("ğŸ•³ï¸  FVG: %dä¸ªæ´»è·ƒ (çœ‹æ¶¨:%d, çœ‹è·Œ:%d), æˆåŠŸç‡: %.1f%%, å¹³å‡å¼ºåº¦: %.1f\n",
			len(result.FairValueGaps.ActiveFVGs),
			stats.ActiveBullishFVGs,
			stats.ActiveBearishFVGs,
			stats.SuccessRate,
			stats.AvgFVGStrength)
	} else {
		fmt.Printf("ğŸ•³ï¸  FVG: æ•°æ®ä¸è¶³\n")
	}
}

// displayKeyLevelsSummary æ˜¾ç¤ºå…³é”®ä»·ä½æ±‡æ€»
func displayKeyLevelsSummary(structure *MarketStructure) {
	if structure == nil || len(structure.KeyLevels) == 0 {
		return
	}

	fmt.Printf("\n=== å…³é”®ä»·ä½æ±‡æ€» (æŒ‰å¼ºåº¦æ’åº) ===\n")
	
	// æŒ‰å¼ºåº¦æ’åºæ˜¾ç¤ºå‰8ä¸ªå…³é”®ä»·ä½
	count := minInt(8, len(structure.KeyLevels))
	for i := 0; i < count; i++ {
		level := structure.KeyLevels[i]
		typeIcon := getTypeIcon(level.Type)
		sourceIcon := getSourceIcon(level.Source)
		fmt.Printf("%s %s %.2f - %s (å¼ºåº¦: %.1f) - %s\n",
			typeIcon, sourceIcon, level.Price, getLevelTypeName(level.Type),
			level.Strength, level.Description)
	}
}

// displayFinalTradingAdvice æ˜¾ç¤ºæœ€ç»ˆäº¤æ˜“å»ºè®®
func displayFinalTradingAdvice(advice *TradingAdvice) {
	if advice == nil {
		return
	}

	fmt.Printf("\n=== ğŸ¯ æœ€ç»ˆäº¤æ˜“å»ºè®® ===\n")
	actionIcon := getActionIcon(advice.OverallAction)
	confidenceLevel := getConfidenceLevel(advice.Confidence)
	
	fmt.Printf("%s å»ºè®®åŠ¨ä½œ: %s (%s - %.1f%%)\n", 
		actionIcon, advice.OverallAction, confidenceLevel, advice.Confidence)
	fmt.Printf("â° æ—¶é—´å‘¨æœŸ: %s\n", advice.TimeHorizon)

	if len(advice.ReasoningPoints) > 0 {
		fmt.Printf("\nğŸ’¡ æ ¸å¿ƒç†ç”±:\n")
		for i, point := range advice.ReasoningPoints {
			fmt.Printf("  %d. %s\n", i+1, point)
		}
	}

	fmt.Printf("\nğŸ“ æ“ä½œç­–ç•¥:\n")
	fmt.Printf("  å…¥åœº: %s\n", advice.EntryStrategy)
	fmt.Printf("  å‡ºåœº: %s\n", advice.ExitStrategy)
	fmt.Printf("  é£æ§: %s\n", advice.RiskManagement)

	if len(advice.AlternativeScenarios) > 0 {
		fmt.Printf("\nğŸ”„ å¤‡é€‰æ–¹æ¡ˆ:\n")
		for i, scenario := range advice.AlternativeScenarios {
			fmt.Printf("  %d. %s\n", i+1, scenario)
		}
	}
}

// displayDetailedModuleAnalysis æ˜¾ç¤ºè¯¦ç»†æ¨¡å—åˆ†æ
func displayDetailedModuleAnalysis(result *ComprehensiveResult) {
	fmt.Printf("\n=== è¯¦ç»†æ¨¡å—åˆ†æ ===\n")

	// FVGè¯¦ç»†åˆ†æ
	if result.FairValueGaps != nil && len(result.FairValueGaps.ActiveFVGs) > 0 {
		fmt.Printf("\nğŸ•³ï¸  æ´»è·ƒFVGè¯¦æƒ…:\n")
		for i, fvg := range result.FairValueGaps.ActiveFVGs {
			if i >= 3 { // æœ€å¤šæ˜¾ç¤º3ä¸ª
				break
			}
			typeIcon := "ğŸ“ˆ"
			if fvg.Type == BearishFVG {
				typeIcon = "ğŸ“‰"
			}
			fmt.Printf("  %s %s %.2f-%.2f (ä¸­å¿ƒ:%.2f, å¼ºåº¦:%.1f, è´¨é‡:%s)\n",
				typeIcon, getFVGTypeName(fvg.Type), fvg.LowerBound, fvg.UpperBound,
				fvg.CenterPrice, fvg.Strength, getFVGQualityName(fvg.Quality))
			fmt.Printf("     å¡«è¡¥è¿›åº¦: %.1f%%, è§¦åŠæ¬¡æ•°: %d, çŠ¶æ€: %s\n",
				fvg.FillProgress, fvg.TouchCount, getFVGStatusName(fvg.Status))
		}
	}

	// ä¾›éœ€åŒºè¯¦ç»†åˆ†æ
	if result.SupplyDemand != nil && len(result.SupplyDemand.ActiveZones) > 0 {
		fmt.Printf("\nâš–ï¸  æ´»è·ƒä¾›éœ€åŒºè¯¦æƒ…:\n")
		for i, zone := range result.SupplyDemand.ActiveZones {
			if i >= 3 { // æœ€å¤šæ˜¾ç¤º3ä¸ª
				break
			}
			typeIcon := "ğŸ”´"
			if zone.Type == DemandZone {
				typeIcon = "ğŸŸ¢"
			}
			fmt.Printf("  %s %s %.2f-%.2f (ä¸­å¿ƒ:%.2f, å¼ºåº¦:%.1f, è´¨é‡:%s)\n",
				typeIcon, getZoneTypeName(zone.Type), zone.LowerBound, zone.UpperBound,
				zone.CenterPrice, zone.Strength, getZoneQualityName(zone.Quality))
			fmt.Printf("     è§¦åŠæ¬¡æ•°: %d, çŠ¶æ€: %s\n",
				zone.TouchCount, getZoneStatusName(zone.Status))
		}
	}
}

// compareAnalysisResults æ¯”è¾ƒä¸¤ä¸ªåˆ†æç»“æœ
func compareAnalysisResults(result1, result2 *ComprehensiveResult, name1, name2 string) {
	fmt.Printf("\n=== ğŸ“Š åˆ†æç»“æœå¯¹æ¯”: %s vs %s ===\n", name1, name2)

	// ä¿¡å·æ•°é‡å¯¹æ¯”
	fmt.Printf("ä¿¡å·æ•°é‡: %s=%d, %s=%d\n", 
		name1, len(result1.UnifiedSignals),
		name2, len(result2.UnifiedSignals))

	// ä¸»è¦å»ºè®®å¯¹æ¯”
	if len(result1.UnifiedSignals) > 0 && len(result2.UnifiedSignals) > 0 {
		fmt.Printf("ä¸»è¦å»ºè®®: %s=%s(%.1f%%), %s=%s(%.1f%%)\n",
			name1, result1.UnifiedSignals[0].Action, result1.UnifiedSignals[0].Confidence,
			name2, result2.UnifiedSignals[0].Action, result2.UnifiedSignals[0].Confidence)
	}

	// é£é™©è¯„ä¼°å¯¹æ¯”
	if result1.RiskAssessment != nil && result2.RiskAssessment != nil {
		fmt.Printf("é£é™©è¯„ä¼°: %s=%s, %s=%s\n",
			name1, getRiskLevelName(result1.RiskAssessment.OverallRisk),
			name2, getRiskLevelName(result2.RiskAssessment.OverallRisk))
	}

	// å„æ¨¡å—æ´»è·ƒæ•°é‡å¯¹æ¯”
	fmt.Printf("\nå„æ¨¡å—æ´»è·ƒæ•°é‡å¯¹æ¯”:\n")
	
	// FVGå¯¹æ¯”
	fvg1Count := 0
	fvg2Count := 0
	if result1.FairValueGaps != nil {
		fvg1Count = len(result1.FairValueGaps.ActiveFVGs)
	}
	if result2.FairValueGaps != nil {
		fvg2Count = len(result2.FairValueGaps.ActiveFVGs)
	}
	fmt.Printf("  FVG: %s=%d, %s=%d\n", name1, fvg1Count, name2, fvg2Count)

	// ä¾›éœ€åŒºå¯¹æ¯”
	sd1Count := 0
	sd2Count := 0
	if result1.SupplyDemand != nil {
		sd1Count = len(result1.SupplyDemand.ActiveZones)
	}
	if result2.SupplyDemand != nil {
		sd2Count = len(result2.SupplyDemand.ActiveZones)
	}
	fmt.Printf("  ä¾›éœ€åŒº: %s=%d, %s=%d\n", name1, sd1Count, name2, sd2Count)
}

// demonstrateTradingDecisionProcess æ¼”ç¤ºäº¤æ˜“å†³ç­–æµç¨‹
func demonstrateTradingDecisionProcess(analyzer *ComprehensiveAnalyzer, symbol string, klines []Kline) {
	fmt.Printf("\n=== ğŸ¯ å®æ—¶äº¤æ˜“å†³ç­–æµç¨‹æ¼”ç¤º ===\n")

	// æ¨¡æ‹Ÿå®æ—¶ä»·æ ¼æ›´æ–°
	currentPrice := klines[len(klines)-1].Close
	fmt.Printf("å½“å‰ä»·æ ¼: %.2f\n", currentPrice)

	// æ‰§è¡Œåˆ†æ
	fmt.Println("\n1. ğŸ“Š æ‰§è¡Œå››æ¨¡å—ç»¼åˆåˆ†æ...")
	result := analyzer.Analyze(symbol, nil, klines)
	
	if result == nil {
		fmt.Println("âŒ åˆ†æå¤±è´¥")
		return
	}

	// åˆ†æç»“æœè¯„ä¼°
	fmt.Printf("2. âœ… åˆ†æå®Œæˆ - ç”Ÿæˆ %d ä¸ªç»Ÿä¸€ä¿¡å·\n", len(result.UnifiedSignals))

	// ä¿¡å·ç­›é€‰
	highPrioritySignals := 0
	mediumPrioritySignals := 0
	for _, signal := range result.UnifiedSignals {
		switch signal.Priority {
		case PriorityHigh:
			highPrioritySignals++
		case PriorityMedium:
			mediumPrioritySignals++
		}
	}

	fmt.Printf("3. ğŸ” ä¿¡å·ç­›é€‰: é«˜ä¼˜å…ˆçº§=%d, ä¸­ä¼˜å…ˆçº§=%d\n", 
		highPrioritySignals, mediumPrioritySignals)

	// é£é™©æ£€æŸ¥
	fmt.Println("4. âš ï¸  é£é™©è¯„ä¼°æ£€æŸ¥...")
	if result.RiskAssessment != nil {
		fmt.Printf("   æ•´ä½“é£é™©: %s\n", getRiskLevelName(result.RiskAssessment.OverallRisk))
		fmt.Printf("   å»ºè®®é£é™©æ•å£: %.1f%%\n", result.RiskAssessment.RecommendedRisk*100)
		fmt.Printf("   æœ€å¤§ä»“ä½: %.1f%%\n", result.RiskAssessment.MaxPositionSize*100)
	}

	// äº¤æ˜“å†³ç­–
	fmt.Println("5. ğŸ¯ äº¤æ˜“å†³ç­–:")
	if highPrioritySignals > 0 {
		fmt.Printf("   âœ… å‘ç° %d ä¸ªé«˜ä¼˜å…ˆçº§ä¿¡å·ï¼Œå»ºè®®æ‰§è¡Œäº¤æ˜“\n", highPrioritySignals)
		if len(result.UnifiedSignals) > 0 {
			signal := result.UnifiedSignals[0]
			fmt.Printf("   ğŸ“ˆ é¦–é€‰ä¿¡å·: %s @ %.2f (ç½®ä¿¡åº¦: %.1f%%)\n", 
				signal.Action, signal.Entry, signal.Confidence)
		}
	} else if mediumPrioritySignals > 0 {
		fmt.Printf("   âš¡ å‘ç° %d ä¸ªä¸­ä¼˜å…ˆçº§ä¿¡å·ï¼Œå»ºè®®è°¨æ…è§‚å¯Ÿ\n", mediumPrioritySignals)
	} else {
		fmt.Printf("   â¸ï¸  æ— æ˜ç¡®ä¿¡å·ï¼Œå»ºè®®ä¿æŒè§‚æœ›\n")
	}

	// é£é™©æé†’
	if result.RiskAssessment != nil && result.RiskAssessment.OverallRisk == RiskHigh {
		fmt.Println("6. âš ï¸  é£é™©æé†’: å½“å‰å¸‚åœºé£é™©è¾ƒé«˜ï¼Œå»ºè®®é™ä½ä»“ä½æˆ–æš‚åœäº¤æ˜“")
	} else {
		fmt.Println("6. âœ… é£é™©å¯æ§ï¼Œå¯æŒ‰è®¡åˆ’æ‰§è¡Œäº¤æ˜“")
	}

	fmt.Println("\nğŸ“‹ å†³ç­–æµç¨‹å®Œæˆï¼Œå»ºè®®ä¿å­˜åˆ†æç»“æœç”¨äºåç»­ç›‘æ§")
}

// è¾…åŠ©å‡½æ•°
func getTrendQualityName(quality TrendQuality) string {
	switch quality {
	case TrendStrong:
		return "å¼ºåŠ²"
	case TrendModerate:
		return "ä¸­ç­‰"
	case TrendWeak:
		return "å¼±åŠ¿"
	default:
		return "æœªçŸ¥"
	}
}

func getFVGTypeName(fvgType FVGType) string {
	switch fvgType {
	case BullishFVG:
		return "çœ‹æ¶¨FVG"
	case BearishFVG:
		return "çœ‹è·ŒFVG"
	default:
		return "æœªçŸ¥FVG"
	}
}

func getFVGQualityName(quality FVGQuality) string {
	switch quality {
	case FVQualityHigh:
		return "é«˜è´¨é‡"
	case FVQualityMedium:
		return "ä¸­ç­‰"
	case FVQualityLow:
		return "ä½è´¨é‡"
	default:
		return "æœªçŸ¥"
	}
}

func getFVGStatusName(status FVGStatus) string {
	switch status {
	case FVGStatusFresh:
		return "æ–°é²œ"
	case FVGStatusTested:
		return "å·²æµ‹è¯•"
	case FVGStatusPartialFill:
		return "éƒ¨åˆ†å¡«è¡¥"
	case FVGStatusFilled:
		return "å·²å¡«è¡¥"
	case FVGStatusExpired:
		return "å·²è¿‡æœŸ"
	default:
		return "æœªçŸ¥"
	}
}

func getZoneTypeName(zoneType ZoneType) string {
	switch zoneType {
	case SupplyZone:
		return "ä¾›ç»™åŒº"
	case DemandZone:
		return "éœ€æ±‚åŒº"
	default:
		return "æœªçŸ¥åŒºåŸŸ"
	}
}

func getZoneQualityName(quality ZoneQuality) string {
	switch quality {
	case QualityStrong:
		return "å¼ºåŠ²"
	case QualityGood:
		return "è‰¯å¥½"
	case QualityModerate:
		return "ä¸­ç­‰"
	case QualityWeak:
		return "å¼±åŠ¿"
	default:
		return "æœªçŸ¥"
	}
}

func getZoneStatusName(status ZoneStatus) string {
	switch status {
	case StatusFresh:
		return "æ–°é²œ"
	case StatusTested:
		return "å·²æµ‹è¯•"
	case StatusWeakened:
		return "å·²å¼±åŒ–"
	case StatusBroken:
		return "å·²çªç ´"
	case StatusExpired:
		return "å·²è¿‡æœŸ"
	default:
		return "æœªçŸ¥"
	}
}

func getTypeIcon(levelType LevelType) string {
	switch levelType {
	case LevelSupport:
		return "ğŸŸ¢"
	case LevelResistance:
		return "ğŸ”´"
	case LevelPOC:
		return "ğŸ¯"
	case LevelVAH:
		return "ğŸ“Š"
	case LevelVAL:
		return "ğŸ“‰"
	default:
		return "âšª"
	}
}

func getSourceIcon(source string) string {
	switch source {
	case "dow_theory":
		return "ğŸ“ˆ"
	case "vpvr_poc", "vpvr_vah", "vpvr_val":
		return "ğŸ“Š"
	case "supply_zone", "demand_zone":
		return "âš–ï¸"
	case "bullish_fvg", "bearish_fvg":
		return "ğŸ•³ï¸"
	default:
		return "ğŸ“"
	}
}

func getActionIcon(action SignalAction) string {
	switch action {
	case ActionBuy:
		return "ğŸš€"
	case ActionSell:
		return "ğŸ“‰"
	case ActionHold:
		return "â¸ï¸"
	case ActionClose:
		return "ğŸ”š"
	default:
		return "â“"
	}
}

func getConfidenceLevel(confidence float64) string {
	if confidence >= 80 {
		return "æé«˜ç½®ä¿¡"
	} else if confidence >= 70 {
		return "é«˜ç½®ä¿¡"
	} else if confidence >= 60 {
		return "ä¸­ç­‰ç½®ä¿¡"
	} else {
		return "ä½ç½®ä¿¡"
	}
}

func max(a, b float64) float64 {
	if a > b {
		return a
	}
	return b
}

func min(a, b float64) float64 {
	if a < b {
		return a
	}
	return b
}

func abs(x float64) float64 {
	if x < 0 {
		return -x
	}
	return x
}